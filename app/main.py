from fastapi import FastAPI, HTTPException, Header
from pydantic import BaseModel
from typing import Literal, Optional, List
from openai import OpenAI
import json
import os
from dotenv import load_dotenv
from supabase import create_client, Client
from pathlib import Path
from datetime import datetime

# Carrega o .env do diret√≥rio raiz do projeto
env_path = Path(__file__).parent.parent / '.env'
load_dotenv(dotenv_path=env_path, override=True)  # override=True for√ßa sobrescrever vari√°veis do sistema

app = FastAPI()

# Supabase client
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_SERVICE_ROLE_KEY")
SUPABASE_BUCKET = os.getenv("SUPABASE_BUCKET")
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

class Message(BaseModel):
    content: str

class ChatRequest(BaseModel):
    message: str
    user_id: Optional[int] = None  # ID do usu√°rio logado (opcional para compatibilidade)
    session_id: Optional[str] = None  # ID da sess√£o para usu√°rios n√£o logados

class ChatResponse(BaseModel):
    response: str
    contexto_utilizado: bool
    chat_id: Optional[int] = None  # ID do chat criado/usado
    historico_usado: bool = False  # Indica se usou hist√≥rico anterior

IntentLiteral = Literal[
    "RETIFICACAO_NOME",
    "HORMONIZACAO",
    "PREVENCAO_IST",
    "DESPEDIDA",
    "BOAS_VINDAS",
    "NAO_ENTENDIDO",
    "OUTROS",
]

class IntentResponse(BaseModel):
    intent: IntentLiteral

ALLOWED_INTENTS = {
    "RETIFICACAO_NOME",
    "HORMONIZACAO",
    "PREVENCAO_IST",
    "DESPEDIDA",
    "BOAS_VINDAS",
    "NAO_ENTENDIDO",
    "OUTROS",
}

PROMPT_INTENT_CLASSIFICATION = """
Voc√™ √© um classificador de inten√ß√£o para um chatbot acolhedor voltado para pessoas trans, focado em orientar sobre retifica√ß√£o de nome, acesso √† hormoniza√ß√£o e preven√ß√£o a ISTs.

Sua tarefa √© analisar a mensagem do usu√°rio e identificar qual inten√ß√£o ela representa, escolhendo apenas UMA das categorias abaixo:

INTEN√á√ïES DISPON√çVEIS:
- RETIFICACAO_NOME
- HORMONIZACAO
- PREVENCAO_IST
- DESPEDIDA
- BOAS_VINDAS
- OUTROS
- NAO_ENTENDIDO  (use se a mensagem for vaga ou n√£o se encaixar em nenhuma das categorias acima)

Regras importantes:

‚Ä¢ RETIFICACAO_NOME: men√ß√µes a retifica√ß√£o/troca de nome, certid√£o, RG, registro civil, cart√≥rio, Defensoria P√∫blica, altera√ß√£o de g√™nero em documentos.
‚Ä¢ HORMONIZACAO: men√ß√µes a hormoniza√ß√£o (HRT), horm√¥nios, acompanhamento m√©dico, ambulat√≥rio trans, endocrinologista, consultas relacionadas √† hormoniza√ß√£o.
‚Ä¢ PREVENCAO_IST: men√ß√µes a preven√ß√£o a IST, testagem, PEP, PrEP, preservativos, sa√∫de sexual, acompanhamento sexual seguro.
‚Ä¢ DESPEDIDA: apenas encerramento (‚Äúobrigado‚Äù, ‚Äúvaleu‚Äù, ‚Äúat√© mais‚Äù, ‚Äútchau‚Äù, ‚Äús√≥ isso‚Äù). Se houver despedida + pedido, ignore a despedida e classifique pelo pedido.
‚Ä¢ BOAS_VINDAS: apenas sauda√ß√£o (‚Äúoi‚Äù, ‚Äúol√°‚Äù, ‚Äúboa tarde‚Äù, ‚Äúe a√≠‚Äù). Se houver sauda√ß√£o + pergunta, ignore a sauda√ß√£o e classifique pela pergunta.
‚Ä¢ NAO_ENTENDIDO: quando a inten√ß√£o da mensagem n√£o ficar claro.
‚Ä¢ OUTROS: quando a mensagem for sobre temas que tanganciem o escopo principal, como d√∫vidas sobre outros assuntos n√£o abordados nessas inten√ß√µes.

FORMATO DE SA√çDA (OBRIGAT√ìRIO):
Responda exatamente em JSON, sem crases e sem texto extra:
{"intent":"<UMA_DAS_INTENCOES_EM_MAIUSCULAS>"}
""".strip()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=OPENAI_API_KEY)

# Debug: verifica se as vari√°veis foram carregadas
print("\n" + "="*80)
print("üîç VERIFICA√á√ÉO DE VARI√ÅVEIS DE AMBIENTE")
print("="*80)
print(f"‚úÖ OPENAI_API_KEY carregada: {OPENAI_API_KEY[:20]}..." if OPENAI_API_KEY else "‚ùå OPENAI_API_KEY N√ÉO encontrada")
print(f"‚úÖ SUPABASE_URL: {SUPABASE_URL}" if SUPABASE_URL else "‚ùå SUPABASE_URL N√ÉO encontrada")
print(f"‚úÖ SUPABASE_BUCKET: {SUPABASE_BUCKET}" if SUPABASE_BUCKET else "‚ùå SUPABASE_BUCKET N√ÉO encontrada")
print("="*80 + "\n")

@app.post("/classify_intent", response_model=IntentResponse)
def classify_intent(message: Message):
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": PROMPT_INTENT_CLASSIFICATION},
                {"role": "user", "content": f"Mensagem do usu√°rio:{message.content}"},
            ],
            temperature=0.3
        )

        raw_text = resp.choices[0].message.content
        raw_text = raw_text.strip().strip("`").strip()
        data = json.loads(raw_text)

        intent = str(data.get("intent", "")).strip().upper()
        if intent not in ALLOWED_INTENTS:
            intent = "NAO_ENTENDIDO"

        return {"intent": intent}

    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Falha ao classificar a inten√ß√£o: {e}")

@app.get("/concatenate_artigos")
def concatenate_artigos():
    """
    Busca todos os documentos .md do bucket knowledge-base
    e concatena o conte√∫do de todos eles.
    """
    try:
        # Lista todos os arquivos do bucket
        files = supabase.storage.from_(SUPABASE_BUCKET).list()
        
        contexto = ""
        artigos_encontrados = []
        
        # Filtra e processa apenas arquivos .md
        for file in files:
            file_name = file.get('name', '')
            
            # Verifica se o arquivo termina com .md (case insensitive)
            if file_name.lower().endswith('.md'):
                artigos_encontrados.append(file_name)
                
                # Faz o download do conte√∫do do arquivo
                try:
                    response = supabase.storage.from_(SUPABASE_BUCKET).download(file_name)
                    
                    # Decodifica o conte√∫do (assumindo que s√£o arquivos de texto)
                    conteudo = response.decode('utf-8')
                    
                    # Adiciona ao contexto com separador
                    contexto += f"\n\n{'='*50}\n"
                    contexto += f"CONTE√öDO DO ARQUIVO: {file_name}\n"
                    contexto += f"{'='*50}\n\n"
                    contexto += conteudo
                    
                except Exception as e:
                    print(f"Erro ao processar arquivo {file_name}: {e}")
                    contexto += f"\n\n[ERRO ao processar {file_name}: {e}]\n\n"
        
        # Print no console para verifica√ß√£o
        print("\n" + "="*80)
        print(f"TOTAL DE ARTIGOS ENCONTRADOS: {len(artigos_encontrados)}")
        print(f"ARQUIVOS: {artigos_encontrados}")
        print("="*80)
        print("\nCONTEXTO CONCATENADO:")
        print(contexto)
        print("\n" + "="*80)
        
        return {
            "success": True,
            "total_artigos": len(artigos_encontrados),
            "arquivos": artigos_encontrados,
            "contexto": contexto
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao buscar artigos: {str(e)}")

def get_contexto_artigos():
    """
    Fun√ß√£o auxiliar para buscar e concatenar todos os arquivos .md.
    Retorna o contexto como string.
    """
    try:
        files = supabase.storage.from_(SUPABASE_BUCKET).list()
        contexto = ""
        
        for file in files:
            file_name = file.get('name', '')
            
            if file_name.lower().endswith('.md'):
                try:
                    response = supabase.storage.from_(SUPABASE_BUCKET).download(file_name)
                    conteudo = response.decode('utf-8')
                    contexto += f"\n\n{'='*50}\n"
                    contexto += f"CONTE√öDO DO ARQUIVO: {file_name}\n"
                    contexto += f"{'='*50}\n\n"
                    contexto += conteudo
                except Exception as e:
                    print(f"Erro ao processar arquivo {file_name}: {e}")
        
        return contexto
    except Exception as e:
        print(f"Erro ao buscar contexto: {e}")
        return ""

def get_or_create_chat(user_id: Optional[int], session_id: Optional[str]):
    """
    Busca ou cria um chat ativo para o usu√°rio ou sess√£o.
    Retorna o ID do chat.
    """
    try:
        # Se n√£o tiver nem user_id nem session_id, cria um tempor√°rio
        if not user_id and not session_id:
            session_id = f"temp_{datetime.now().timestamp()}"
        
        # Busca um chat ativo existente
        if user_id:
            # Verifica se o usu√°rio existe na tabela users
            user_check = supabase.table('users').select('id').eq('id', user_id).execute()
            
            # Se o usu√°rio n√£o existir, usa session_id ao inv√©s
            if not user_check.data:
                print(f"‚ö†Ô∏è User ID {user_id} n√£o encontrado, usando session_id")
                session_id = f"user_{user_id}_temp"
                user_id = None
                result = supabase.table('chats').select('id').eq('session_id', session_id).eq('is_active', True).order('created_at', desc=True).limit(1).execute()
            else:
                result = supabase.table('chats').select('id').eq('user_id', user_id).eq('is_active', True).order('created_at', desc=True).limit(1).execute()
        elif session_id:
            result = supabase.table('chats').select('id').eq('session_id', session_id).eq('is_active', True).order('created_at', desc=True).limit(1).execute()
        else:
            result = None
        
        # Se encontrou um chat ativo, retorna o ID
        if result and result.data:
            return result.data[0]['id']
        
        # Caso contr√°rio, cria um novo chat
        new_chat = {
            'user_id': user_id,  # Pode ser None
            'session_id': session_id,
            'title': 'Nova conversa',
            'is_active': True,
            'created_at': datetime.now().isoformat(),
            'updated_at': datetime.now().isoformat()
        }
        
        result = supabase.table('chats').insert(new_chat).execute()
        return result.data[0]['id']
        
    except Exception as e:
        print(f"Erro ao buscar/criar chat: {e}")
        raise HTTPException(status_code=500, detail=f"Erro ao gerenciar chat: {str(e)}")

def get_chat_history(chat_id: int, limit: int = 30):
    """
    Busca as √∫ltimas mensagens de um chat.
    Retorna lista de mensagens no formato [{"role": "user/assistant", "content": "..."}]
    """
    try:
        result = supabase.table('chat_messages').select('role, content').eq('chat_id', chat_id).order('created_at', desc=False).limit(limit).execute()
        
        if not result.data:
            return []
        
        # Converte para o formato esperado pela OpenAI
        messages = []
        for msg in result.data:
            messages.append({
                "role": msg['role'],
                "content": msg['content']
            })
        
        return messages
        
    except Exception as e:
        print(f"Erro ao buscar hist√≥rico: {e}")
        return []

def save_message(chat_id: int, role: str, content: str):
    """
    Salva uma mensagem no banco de dados.
    """
    try:
        message = {
            'chat_id': chat_id,
            'role': role,
            'content': content,
            'created_at': datetime.now().isoformat()
        }
        
        supabase.table('chat_messages').insert(message).execute()
        
        # Atualiza o timestamp do chat
        supabase.table('chats').update({'updated_at': datetime.now().isoformat()}).eq('id', chat_id).execute()
        
    except Exception as e:
        print(f"Erro ao salvar mensagem: {e}")
        # N√£o lan√ßa exce√ß√£o para n√£o quebrar o fluxo

def get_user_info(user_id: int) -> Optional[dict]:
    """
    Busca as informa√ß√µes do usu√°rio (nome, nome social e pronome) da tabela users.
    Retorna um dict com 'name', 'social_name' e 'pronoun', ou None se n√£o encontrado.
    """
    try:
        result = supabase.table('users').select('name, social_name, pronoun').eq('id', user_id).single().execute()
        if result.data:
            return {
                'name': result.data.get('name'),
                'social_name': result.data.get('social_name'),
                'pronoun': result.data.get('pronoun')
            }
        return None
    except Exception as e:
        print(f"Erro ao buscar informa√ß√µes do usu√°rio: {e}")
        return None

def get_preferred_name_and_pronoun(user_id: Optional[int]) -> Optional[dict]:
    """
    Retorna o nome preferido e pronome do usu√°rio.
    Prioriza nome social sobre nome.
    Retorna: {'name': str, 'pronoun': str} ou None
    """
    if not user_id:
        return None
    
    user_info = get_user_info(user_id)
    if not user_info:
        return None
    
    # Prioriza o nome social, se dispon√≠vel
    preferred_name = user_info.get('social_name') or user_info.get('name')
    pronoun = user_info.get('pronoun')
    
    if not preferred_name:
        return None
    
    return {
        'name': preferred_name,
        'pronoun': pronoun if pronoun else None
    }

@app.post("/chat", response_model=ChatResponse)
def chat_with_context(request: ChatRequest):
    """
    Endpoint para conversar com o ChatGPT usando o contexto dos artigos e hist√≥rico de conversas.
    
    O contexto dos artigos √© automaticamente adicionado.
    O hist√≥rico das √∫ltimas 30 mensagens √© recuperado do banco de dados.
    Se o usu√°rio estiver autenticado (user_id), busca o nome social ou nome da tabela users.
    """
    try:
        # 1. Busca ou cria um chat para o usu√°rio/sess√£o
        chat_id = get_or_create_chat(request.user_id, request.session_id)
        
        # 2. Busca o hist√≥rico de mensagens (√∫ltimas 30)
        historico = get_chat_history(chat_id, limit=30)
        historico_usado = len(historico) > 0
        
        # 3. Busca o nome e pronome do usu√°rio (se estiver autenticado)
        user_info = get_preferred_name_and_pronoun(request.user_id)
        user_name = user_info.get('name') if user_info else None
        user_pronoun = user_info.get('pronoun') if user_info else None
        
        # 4. Busca o contexto dos artigos
        contexto = get_contexto_artigos()
        
        if not contexto:
            raise HTTPException(status_code=500, detail="N√£o foi poss√≠vel carregar o contexto dos artigos")
        
        # 5. Monta o prompt do sistema com divis√µes claras
        # Adiciona se√ß√£o do nome e pronome se dispon√≠vel
        nome_section = ""
        if user_name:
            pronoun_text = f"\nüó£Ô∏è PRONOME PREFERIDO: {user_pronoun}" if user_pronoun else ""
            nome_section = f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üë§ INFORMA√á√ïES DO(A) INTERLOCUTOR(A)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìõ NOME: {user_name}{pronoun_text}

INSTRU√á√ïES DE USO:
- Use o nome de forma respeitosa e acolhedora durante a conversa
- Personalize suas respostas chamando a pessoa pelo nome quando apropriado
- {"Use o pronome '" + user_pronoun + "' nas conjuga√ß√µes e refer√™ncias" if user_pronoun else "Use linguagem neutra quando n√£o souber o pronome"}
- Exemplos de linguagem inclusiva: "bem-vinde", "queride" (quando aplic√°vel)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        
        prompt_sistema = f"""{nome_section}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìö SE√á√ÉO 1: BASE DE CONHECIMENTO (Artigos de Refer√™ncia)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

{contexto}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üéØ INSTRU√á√ïES PARA O ASSISTENTE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Voc√™ √© um assistente especializado em orientar pessoas trans sobre:
- Retifica√ß√£o de nome e g√™nero
- Terapia hormonal (hormoniza√ß√£o)
- Preven√ß√£o e tratamento de ISTs

IMPORTANTE:
- Use APENAS as informa√ß√µes da BASE DE CONHECIMENTO acima
- Se houver HIST√ìRICO DE CONVERSAS abaixo, mantenha coer√™ncia com elas
- Responda de forma sucinta, acolhedora e respeitosa
- Use emojis quando apropriado, mas de forma moderada
- N√£o use termos muito t√©cnicos e evite refor√ßar esteri√≥tipos
- Se n√£o souber algo que n√£o est√° na base de conhecimento, seja honesto
- Use linguagem neutra e inclusiva sempre

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        
        # 6. Monta a lista de mensagens
        messages = [{"role": "system", "content": prompt_sistema}]
        
        # 7. Adiciona o hist√≥rico com marca√ß√£o clara
        if historico:
            historico_formatado = "\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            historico_formatado += f"üí¨ SE√á√ÉO 2: HIST√ìRICO DA CONVERSA ({len(historico)} mensagens anteriores)\n"
            historico_formatado += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"
            
            for i, msg in enumerate(historico, 1):
                role_label = "USU√ÅRIO" if msg['role'] == 'user' else "ASSISTENTE"
                historico_formatado += f"[Mensagem {i} - {role_label}]:\n{msg['content']}\n\n"
            
            historico_formatado += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            
            # Adiciona como mensagem do sistema para contexto
            messages.append({"role": "system", "content": historico_formatado})
        
        # 7. Adiciona separador e a pergunta atual
        mensagem_atual = f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚ùì SE√á√ÉO 3: PERGUNTA ATUAL DO USU√ÅRIO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

{request.message}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        
        messages.append({"role": "user", "content": mensagem_atual})
        
        # 8. Chama a API do OpenAI
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=messages,
            temperature=0.7,
            max_tokens=1000
        )
        
        resposta = response.choices[0].message.content
        
        # 7. Salva a mensagem do usu√°rio e a resposta no banco
        save_message(chat_id, "user", request.message)
        save_message(chat_id, "assistant", resposta)
        
        # Print para debug
        print("\n" + "="*80)
        print(f"üí¨ CHAT ID: {chat_id}")
        if user_name:
            pronoun_display = f" ({user_pronoun})" if user_pronoun else ""
            print(f"üë§ NOME DO USU√ÅRIO: {user_name}{pronoun_display}")
        else:
            print(f"üë§ NOME DO USU√ÅRIO: An√¥nimo")
        print(f"ÔøΩ HIST√ìRICO USADO: {len(historico)} mensagens")
        print(f"‚ùì PERGUNTA DO USU√ÅRIO: {request.message}")
        print(f"ü§ñ RESPOSTA: {resposta}")
        print("="*80 + "\n")
        
        return {
            "response": resposta,
            "contexto_utilizado": True,
            "chat_id": chat_id,
            "historico_usado": historico_usado
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao processar chat: {str(e)}")

@app.get("/chat/history/{chat_id}")
def get_chat_history_endpoint(chat_id: int, limit: int = 50):
    """
    Busca o hist√≥rico de mensagens de um chat espec√≠fico.
    """
    try:
        messages = get_chat_history(chat_id, limit)
        return {
            "chat_id": chat_id,
            "total_messages": len(messages),
            "messages": messages
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao buscar hist√≥rico: {str(e)}")

@app.get("/chats/user/{user_id}")
def get_user_chats(user_id: int):
    """
    Lista todos os chats de um usu√°rio.
    """
    try:
        result = supabase.table('chats').select('id, title, created_at, updated_at, is_active').eq('user_id', user_id).order('updated_at', desc=True).execute()
        
        return {
            "user_id": user_id,
            "total_chats": len(result.data),
            "chats": result.data
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao buscar chats: {str(e)}")

@app.delete("/chat/{chat_id}")
def delete_chat(chat_id: int):
    """
    Desativa um chat (soft delete).
    """
    try:
        supabase.table('chats').update({'is_active': False}).eq('id', chat_id).execute()
        return {"success": True, "message": f"Chat {chat_id} desativado com sucesso"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao desativar chat: {str(e)}")

@app.post("/chat/{chat_id}/new")
def start_new_chat(user_id: Optional[int] = None, session_id: Optional[str] = None):
    """
    Inicia um novo chat para o usu√°rio (desativa o atual e cria um novo).
    """
    try:
        # Desativa chats antigos
        if user_id:
            supabase.table('chats').update({'is_active': False}).eq('user_id', user_id).eq('is_active', True).execute()
        elif session_id:
            supabase.table('chats').update({'is_active': False}).eq('session_id', session_id).eq('is_active', True).execute()
        
        # Cria novo chat
        chat_id = get_or_create_chat(user_id, session_id)
        
        return {
            "success": True,
            "chat_id": chat_id,
            "message": "Novo chat criado com sucesso"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao criar novo chat: {str(e)}")
